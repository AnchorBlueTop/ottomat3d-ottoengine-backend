# OTTOMAT3D Backend - Claude Code Instructions

## Project Overview

OTTOMAT3D is a sophisticated 24/7 automated 3D printing manufacturing system that coordinates multiple printers, ejection devices, and storage racks for continuous unattended production.

**Current Phase:** Multi-Printer Brand Support - Material Station & Calibration API Complete
**Backend Version:** v0.3 (Production Ready - Phase 3 Complete)
**Tech Stack:** Node.js + Express + SQLite + MQTT + Event-Driven Architecture

## üìç CURRENT SESSION STATUS (November 2025)

**Active Branch:** `feat/flashforge-adapter` (local only - NOT pushed to remote)
**Last Completed:** Material Station Support + Printer Calibration API implementation
**Session Date:** November 13, 2025

### ‚úÖ Just Completed (This Session):

1. **Material Station Support (use_ams Parameter)**
   - **What:** Unified parameter for Bambu AMS and FlashForge Material Station
   - **Files Modified:**
     - `src/controllers/printJobController.js:125` - Accept use_ams from request body
     - `src/services/printJobService.js:146,187,202` - Store in database
     - `.claude_code` - Added comprehensive documentation (lines 117-145)
   - **API Change:** `POST /api/print-jobs` now accepts `use_ams: true/false`
   - **Database:** Uses existing `print_jobs.use_ams` column (INTEGER, default: 0)
   - **Testing:** None - user will test all features tomorrow in office

2. **Printer Calibration API (Brand-Specific)**
   - **What:** `POST /api/printers/:id/calibrate` - Moves printer bed to calibration position
   - **Files Created:**
     - `backend/gcode/Z_POS_DWELL.gcode` (2.1KB) - Prusa Z-bed dwell file
     - `backend/gcode/Y_POS_DWELL.gcode` (147KB) - Prusa sling-bed dwell file
     - `backend/gcode/ELEGOO_Z205_PLA.gcode` (202KB) - Elegoo calibration print
   - **Files Modified:**
     - `src/routes/printerApiRoutes.js:87` - New calibrate route
     - `src/controllers/printerController.js:380-397` - calibratePrinter() handler
     - `src/services/printerService.js:703-949` - Main calibration logic + 6 brand handlers
     - `.claude_code` - Added comprehensive documentation (lines 147-211)
   - **Brand Logic:**
     - Bambu Lab: G28 + G90 + G1 Y170/Z200 (bed type detection)
     - FlashForge: TCP sequence (~M601 ‚Üí ~G28 Z0 ‚Üí ~G1 Z190 F600 ‚Üí ~M602)
     - Creality: G28 Z + G1 Z230 F600
     - Anycubic: G28 Z + G1 Z213 F600 (**+13mm compensation - CRITICAL**)
     - Prusa: Upload and start dwell file (Z_POS_DWELL.gcode or Y_POS_DWELL.gcode)
     - Elegoo: Upload ELEGOO_Z205_PLA.gcode and start calibration print
   - **Source:** Ported from `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/operations/calibration.py`
   - **Testing:** None - user will test tomorrow

### üéØ Implementation Notes for Next Session:

**CRITICAL REMINDERS:**
- ‚ùå DO NOT push `feat/flashforge-adapter` branch to remote (keep local)
- ‚ùå DO NOT merge any branches to develop yet (user will review first)
- ‚ùå DO NOT test any implementations (user tests tomorrow in office)
- ‚úÖ All code ported EXACTLY from beta script (calibration.py, printer classes)
- ‚úÖ Anycubic +13mm compensation is intentional (line 838 in printerService.js)

**Current Branch State:**
```bash
git branch  # Should show: feat/flashforge-adapter (or similar adapter branch)
git status  # Should show modified files: printJobController, printJobService, printerController, printerService, printerApiRoutes, .claude_code
```

**Modified Files Summary:**
1. `src/controllers/printJobController.js` - Line 125: use_ams parameter
2. `src/services/printJobService.js` - Lines 146, 187, 202: use_ams handling
3. `src/routes/printerApiRoutes.js` - Line 87: calibrate route
4. `src/controllers/printerController.js` - Lines 380-397: calibratePrinter()
5. `src/services/printerService.js` - Lines 703-949: calibration logic (247 lines added)
6. `backend/gcode/` - 3 calibration files copied
7. `.claude_code` - Comprehensive documentation added

**What's Working:**
- Material Station parameter flows: API ‚Üí Controller ‚Üí Service ‚Üí Database
- Calibration endpoint registered and wired up
- All 6 brand-specific calibration handlers implemented
- Error handling and logging in place
- Documentation complete

**Next Steps (If Continuing):**
1. Optional: Commit changes to current branch with message like:
   ```
   feat: Add Material Station support and Printer Calibration API

   - Add use_ams parameter to print job creation
   - Implement POST /api/printers/:id/calibrate endpoint
   - Add brand-specific calibration logic for all 6 printer brands
   - Copy calibration G-code files from beta script
   - Add Anycubic +13mm compensation for calibration
   ```

2. If user approves: Push branch to remote and create MR to develop
3. Otherwise: Wait for user testing feedback tomorrow

**Beta Script Reference Paths:**
- Calibration: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/operations/calibration.py`
- Printers: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/printers/`
- G-code files: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/gcode/`

---

## üîÑ Recent Updates (November 2025)

### üéØ Multi-Printer Brand Support Implementation

**Current Phase:** Porting Python beta script features to Node.js backend
**Status:** Adapters Complete - Material Station + Calibration API Added
**Approach:** Separate branches per adapter, schema branch MR'd separately

**Supported Printer Brands (Priority Order):**
1. ‚úÖ Bambu Lab (P1P, P1S, X1C, A1) - Enhanced with AMS support
2. ‚úÖ FlashForge (AD5X, Adventure 5M Pro) - Material Station + dual HTTP/TCP
3. ‚úÖ Creality (K1C) - WebSocket protocol, no bed positioning
4. ‚úÖ Anycubic (Kobra S1) - Moonraker + LeviQ bed leveling
5. ‚è≥ Elegoo (Centuari Carbon) - Moonraker + G-code modification
6. ‚è≥ Prusa (MK3/MK4/Core One) - PrusaLink API

**Branch Structure:**
- `feat/multi-printer-auth-schema` - MR'd separately (auth fields: serial_code, check_code, api_key)
- `feat/bambu-ams-support` - ‚úÖ Complete (AMS mapping, bed positioning, FTP file listing)
- `feat/flashforge-adapter` - ‚úÖ Complete (dual HTTP/TCP, Material Station, platform clearing)
- `feat/creality-adapter` - ‚úÖ Complete (WebSocket communication, K1C support)
- `feat/anycubic-adapter` - ‚úÖ Complete (Moonraker HTTP API, LeviQ sequence)
- Future: `feat/elegoo-adapter`, `feat/prusa-adapter`

**Key Architecture Changes:**
- Each printer brand has dedicated adapter in `packages/integration-adapter/vendors/[brand]/`
- Unified bed positioning via `adapter.positionBedForEjection()` method
- Material system support: Bambu AMS, FlashForge Material Station
- Brand-specific authentication stored in printers table

**FlashForge Implementation Details:**
- Dual communication: HTTP (port 8898) + TCP (port 8899)
- HTTP for status, job control, file upload
- TCP for G-code commands (bed positioning)
- Material Station auto-mapping (empty materialMappings array)
- Platform state clearing before ejection
- Full authentication: serial_code + check_code

**Creality Implementation Details:**
- WebSocket communication (port 9999)
- Status via WebSocket JSON messages (method: 'get_status')
- Print start via WebSocket (method: 'set', params: {opGcodeFile})
- NO bed positioning needed (positionBedForEjection is no-op)
- Authentication: IP address only (printer must be ROOTED)
- Status codes: 0=IDLE, 1=PRINTING, 2=PAUSED, 3=ERROR, 4=FINISHED
- File path format: printprt:/usr/data/printer_data/gcodes/{filename}

**Anycubic Implementation Details:**
- Moonraker HTTP API (port 7125)
- Requires Rinkhals Custom Firmware
- LeviQ bed leveling sequence: AUTO_ZOFFSET ‚Üí PREHEATING ‚Üí WIPING ‚Üí PROBE ‚Üí SDCARD_PRINT
- Status via /printer/objects/query endpoint (print_stats, virtual_sdcard, temps)
- Print control: pause, resume, cancel supported
- Fallback bed positioning: G1 Z205 (should be in end G-code)
- Authentication: IP address only
- File listing supported via /server/files/list

**üéØ NEW: Printer-Specific Completion Detection Architecture**

All adapters now implement `waitForCompletion()` method with brand-specific logic ported from beta scripts:

**Completion Detection Logic by Brand:**

1. **Bambu Lab** (`waitForCompletion()` - 165 lines):
   - Grace period: Don't accept IDLE until PRINTING state seen
   - Initial IDLE count tracking (max 10 before failing)
   - IDLE completion after printing (99%, no time remaining, consecutive checks)
   - Error state detection (PAUSED, FAILED, OFFLINE, etc.)
   - Adaptive polling: 60s (>10min), 30s (2-10min), 10s (<2min), 5s (>99%)

2. **Creality** (`waitForCompletion()` - 201 lines):
   - **99% stuck logic**: ERROR/PAUSED/IDLE at 99% = completion (NOT failure)
   - WebSocket reconnection with exponential backoff (max 5s)
   - Failed to start detection (IDLE + 0% + no file)
   - Throttled logging (every 10 seconds)
   - Persistent status across connection drops

3. **Anycubic** (`waitForCompletion()` - 198 lines):
   - **Stale status detection**: Handles COMPLETE from previous prints
   - Wait for status transition (max 300s) + progress reset (max 600s)
   - 60-second grace period for CANCELLED states (6 polls)
   - **Temperature-based completion**: IDLE + nozzle<50¬∞C + bed<40¬∞C + progress>80%
   - ERROR states as warnings only (false positives common)
   - Adaptive polling: 10s (active), 5s (>95%), 8s (>80%), 10s (standard)

4. **FlashForge** (`waitForCompletion()` - 90 lines):
   - **99.5% threshold** (higher than other printers)
   - Accepts both "ready" and "stop" states as potential completion
   - Adaptive polling: 30s (<90%), 10s (90-99%), 5s (>99%)
   - Throttled logging (only when status changes)
   - Consecutive error tracking (fails after >4 errors)

**Orchestrator Integration** (`orchestratorService.js`):
- `_startPrintProgressMonitoring()` now checks for adapter.waitForCompletion()
- If available: Uses adapter-specific logic (RECOMMENDED)
- If not available: Falls back to legacy 30s polling
- Progress callback updates database and logs status
- Automatic error handling and resource cleanup

**Benefits:**
‚úÖ Exact beta script logic - tested and proven
‚úÖ Handles all edge cases per brand (stale status, 99% stuck, grace periods)
‚úÖ Reduces false failures from generic polling
‚úÖ Adaptive intervals minimize API load
‚úÖ Backwards compatible with legacy polling

**üéØ NEW: Material Station Support (use_ams Parameter)**

Material system support is now unified across all printers using the `use_ams` parameter:
- **Bambu Lab**: AMS (Automatic Material System)
- **FlashForge**: Material Station (4-spool system)
- Other brands: Parameter is accepted but has no effect

**Database Schema:**
- `print_jobs.use_ams` (INTEGER, default: 0) - Enables material system for the job

**API Changes:**
- `POST /api/print-jobs` - Accepts optional `use_ams` boolean parameter
- Controller: `printJobController.createPrintJob()` - Extracts use_ams from request body
- Service: `printJobService.createPrintJob()` - Stores use_ams in database
- Orchestrator: Passes use_ams to adapter.start() via JobSpec

**Usage:**
```json
{
    "print_item_id": 1,
    "printer_id": 1,
    "ottoeject_id": 1,
    "rack_id": 1,
    "store_location": 4,
    "grab_location": 3,
    "use_ams": true,  // Enable material system
    "auto_start": true
}
```

**üéØ NEW: Printer Calibration API**

Brand-specific calibration endpoint for OttoEject positioning: `POST /api/printers/:id/calibrate`

**Implementation:**
- Route: `printerApiRoutes.js:87` - `router.post('/:id/calibrate', printerController.calibratePrinter)`
- Controller: `printerController.js:380` - Validates printer ID and delegates to service
- Service: `printerService.js:703` - Main entry point with brand detection
- Calibration files: `backend/gcode/` - Z_POS_DWELL.gcode, Y_POS_DWELL.gcode, ELEGOO_Z205_PLA.gcode

**Brand-Specific Calibration Logic:**

1. **Bambu Lab** (`_calibrateBambuLab` - 28 lines):
   - Home all axes: `G28` (required by Bambu Lab)
   - A1 (sling bed): `G90\nG1 Y170 F1000` - Move to Y170mm
   - P1P/P1S/X1C (z bed): `G90\nG1 Z200 F600` - Move to Z200mm

2. **FlashForge** (`_calibrateFlashForge` - 37 lines):
   - TCP sequence on port 8899
   - Login: `~M601 S1`
   - Home Z: `~G28 Z0`
   - Move: `~G90` ‚Üí `~G1 Z190 F600`
   - Wait commands: `~M400` (between operations)
   - Logout: `~M602`

3. **Creality** (`_calibrateCreality` - 16 lines):
   - Moonraker/WebSocket G-code commands
   - Home Z: `G28 Z`
   - Move: `G1 Z230 F600`
   - No compensation needed

4. **Anycubic** (`_calibrateAnycubic` - 26 lines):
   - **CRITICAL**: +13mm compensation (line 838)
   - Compensates for G-code end positioning vs manual console commands
   - Home Z: `G28 Z`
   - Move: `G1 Z213 F600` (Z200 + 13mm)
   - Recommended position displayed: Z200mm (actual: Z213mm)

5. **Prusa** (`_calibratePrusa` - 47 lines):
   - Uses dwell files for positioning
   - Core One (z_bed): Uploads and starts `Z_POS_DWELL.gcode` ‚Üí `OTTOTEMP/Z_POS_DWELL.gcode`
   - MK3/MK4 (sling_bed): Uploads and starts `Y_POS_DWELL.gcode` ‚Üí `OTTOTEMP/Y_POS_DWELL.gcode`
   - Dwell files move bed to position and pause automatically

6. **Elegoo** (`_calibrateElegoo` - 40 lines):
   - Uploads `ELEGOO_Z205_PLA.gcode` (OTTOMAT3D Logo calibration print)
   - Starts calibration print (duration: ~10-15 minutes)
   - Print ends with bed at Z205mm
   - User can observe print via Elegoo web interface

**Response Format:**
```json
{
    "message": "Calibration complete: Bed moved to Z200mm"
}
```

**Error Handling:**
- 400: Invalid printer ID
- 500: Calibration failed, adapter not available, or unsupported brand
- Returns meaningful error messages for debugging

**Calibration File Sources:**
- Copied from beta script: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/gcode/`
- Backend location: `/Users/harshilpatel/Desktop/Projects/MCP/ottostudio/backend/gcode/`

**Reference Files for Remaining Adapters:**
- Creality: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/printers/creality_printer.py`
- Anycubic: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/printers/anycubic_printer.py`
- Elegoo: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/printers/elegoo_printer.py`
- Prusa: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/printers/prusa_printer.py`
- G-code processor: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/utils/gcode_processor.py`
- Ejection sequence: `/Users/harshilpatel/Desktop/Projects/MCP/ottomat3d-beta-test/src/operations/ejection.py`

**Files Created:**
- `packages/integration-adapter/vendors/flashforge/hybrid.js` (702 lines)
- `packages/integration-adapter/vendors/creality/websocket.js` (553 lines)
- `packages/integration-adapter/vendors/anycubic/moonraker.js` (445 lines)
- Enhanced `packages/integration-adapter/vendors/bambu/lan.js` with AMS + positioning

**Files Modified:**
- `db/schema.sql` - Added printer auth fields, use_ams/use_material_station on print_jobs
- `packages/integration-adapter/registry.js` - Registered FlashForge, Creality, and Anycubic adapters
- `src/services/printerService.js` - Brand-specific auth validation, Creality/Anycubic comments
- `src/services/printJobService.js` - Accept use_ams/use_material_station params
- `src/controllers/printJobController.js` - Pass material system flags
- `src/services/orchestratorService.js` - Delegate bed positioning to adapters

**Testing Strategy:**
- No testing during implementation (user will test all adapters tomorrow in office)
- Branches kept separate for individual MRs, NOT merged to develop yet
- Schema already applied to each adapter branch

**Next Steps (In Priority Order):**
1. ‚úÖ Creality K1C adapter (WebSocket protocol, NO bed positioning needed) - COMPLETE
2. Anycubic Kobra S1 adapter (Moonraker HTTP API + LeviQ bed leveling sequence)
3. Elegoo Centuari Carbon adapter (Moonraker HTTP API + G-code file modification for bed positioning)
4. Prusa MK3/MK4/Core One adapter (PrusaLink REST API + positioning print job approach)
5. Frontend updates (ONLY AFTER all backend adapters complete, before packaging)

**Frontend Todo List (DO LAST, BEFORE PACKAGING):**
- Add brand/model selection dropdown to printer form
- Add conditional auth fields based on selected brand:
  - Bambu Lab: access_code + serial_number (already exists)
  - FlashForge: serial_code + check_code
  - Prusa: api_key
  - Creality/Anycubic/Elegoo: IP only
- Add AMS checkbox to print job form (Bambu Lab only)
- Add Material Station checkbox to print job form (FlashForge only)
- Show/hide checkboxes based on selected printer brand
- Test printer connection UI updates (already has /api/printers/connect endpoint)

**IMPORTANT REMINDERS:**
- DO NOT push branches to remote yet (keep local until user approves)
- DO NOT merge any branches to develop yet (separate MRs later)
- NO TESTING during implementation (user will test tomorrow in office)
- Copy exact implementations from beta script Python files to avoid testing issues
- Each adapter branch already has schema changes applied from feat/multi-printer-auth-schema

---

### üéØ MAJOR PIVOT: Manual Orchestration System

**Branch:** `feat/manual-orchestration`
**Status:** Ready for MR to `main`

**Strategic Decision:** Moved from automatic slot assignment to **full manual control** for product launch. This gives users complete visibility and control over their print farm operations.

**What Changed:**
- ‚ùå **Removed:** Automatic printer selection, automatic rack assignment, automatic slot picking
- ‚úÖ **Added:** Manual printer, rack, and slot selection via API
- ‚úÖ **Added:** Comprehensive validation system (`ManualSlotValidator.js`)
- ‚úÖ **Enhanced:** Orchestrator console output with smart state tracking
- ‚úÖ **Fixed:** Database schema relationships (ottoejects ‚Üî storage_racks)

**Key Implementation Details:**

**New Required API Parameters (POST /api/print-jobs):**
```json
{
    "print_item_id": 1,
    "printer_id": 1,        // User selects printer
    "ottoeject_id": 1,      // User selects ottoeject
    "rack_id": 1,           // User selects rack
    "store_location": 4,    // User selects store slot
    "grab_location": 3,     // User selects grab slot
    "auto_start": true,
    "priority": 1
}
```

**Database Schema Corrections:**
- **Before:** `ottoejects.rack_id` (1 ottoeject ‚Üí 1 rack) ‚ùå
- **After:** `storage_racks.ottoeject_id` (1 ottoeject ‚Üí many racks) ‚úÖ

**Validation System:**
- Validates printer exists
- Validates rack exists and belongs to ottoeject
- Validates store slot is empty and available
- Validates grab slot has empty plate
- Prevents slot conflicts and invalid assignments

**Orchestrator Improvements:**
- Filters jobs with busy printers before processing (no spam)
- Only shows queue status when state changes (not every 5 seconds)
- Displays rack names instead of IDs (`Rack A` vs `Rack 1`)
- Shows both store AND grab slots for all jobs
- Clean, actionable console output

**What's Preserved for Future:**
- `AdvancedSlotManager.js` - Height-aware automatic assignment (Phase 2)
- `_findAvailablePrinter()` - Automatic printer selection (Phase 2)
- Can be re-enabled via config flag post-launch

**Files Added:**
- `src/utils/ManualSlotValidator.js` - Validation logic
- `_testing/unit-test-2.js` - Manual orchestration test script

**Files Modified:**
- `src/controllers/printJobController.js` - Added rack_id validation
- `src/services/printJobService.js` - Uses manual assignments
- `src/services/orchestratorService.js` - Smart queue display, spam reduction
- `db/schema.sql` - Fixed relationships
- `src/bambulabs-api/mqtt-client.js` - Suppressed noisy logs

---

**‚úÖ ALL Phase 3 Feature Branches Merged to Develop:**

1. ‚úÖ `feat/backend-config` - Centralized configuration system
   - Added `/backend/src/config/` directory with centralized config management
   - Environment-based configuration for all backend services

2. ‚úÖ `feat/update-schema` - Enhanced database schema with plate tracking
   - Updated schema with improved plate state tracking
   - Enhanced foreign key relationships
   - **CRITICAL**: Includes `has_build_plate` column required by orchestrator

3. ‚úÖ `feat/use-bambu-adapter` - Improved adapter layer with better connection management
   - BambuLanAdapter with enhanced authenticate() methods
   - Better error handling and connection state management
   - Adapter pattern properly implemented for multi-brand support

4. ‚úÖ `feat/printer-connect-api-fixed` - Connection test API endpoint (WITH SCOPE CREEP)
   - Added `POST /api/printers/connect` endpoint
   - Controller: `printerController.connect()`
   - Service: `printerService.connect()` (uses direct bl_api for lightweight testing)
   - Route: `router.post('/connect', express.json(), printerController.connect)`
   - **‚ö†Ô∏è SCOPE CREEP ALERT**: MR also included:
     - New tables: `job_events`, `ejection_sessions` (observability features)
     - New services: `ejectionSessionService.js`, `jobEventService.js`
     - Schema changes that attempted to remove `has_build_plate` (REJECTED - breaks orchestrator!)
   - See `docs/reference/MERGE_ANALYSIS.md` for full details

5. ‚úÖ `feat/job-observability` - Job event logging and ejection session tracking
   - Enhanced job monitoring and event logging
   - Improved observability for print job lifecycle
   - Tables: `job_events`, `ejection_sessions`

6. ‚úÖ `fix/orchestrator-fixes` - Enhanced orchestrator logging and monitoring
   - Improved orchestrator service logging
   - Better error handling and status reporting

**Testing Branches:**
- ‚úÖ `feat/unit-testing` - Automated test setup script (merged)
  - Script: `_testing/unit-test-1.js` - Automated system configuration
  - Docs: `_testing/UNIT_TEST_GUIDE.md` - Complete usage guide
  - Creates printers, ottoejects, racks, print jobs automatically
  - Users must update file paths in config (lines 67-70)
- `test/unit-test-printer-service` - Legacy (use feat/unit-testing instead)

**Current Branch:** `feat/manual-orchestration`
**Purpose:** Manual orchestration system for product launch (replaces automatic assignment)

**Key Architectural Decisions:**
- Connection test API (`/api/printers/connect`) uses **direct bl_api** for temporary/lightweight validation
- Normal printer operations use **BambuLanAdapter** for persistent, managed connections
- This separation is intentional: connection tests don't need full adapter overhead

**Schema Integrity Rules:**
- **NEVER remove `has_build_plate`** - Required by orchestrator (lines 350, 732, 761 in orchestratorService.js)
- **NEVER remove `occupied`** - Backwards compatibility with rack slot model
- **ALWAYS keep** `type NOT NULL` in printers table
- New tables (`job_events`, `ejection_sessions`) are ADDITIVE only

**Files Cleaned Across All Branches:**
- Removed `database-erd.png` (personal file)
- Removed `README.md` changes (reverted to develop)
- Removed migration scripts (`db/migrations/*.sql`, `db/run_migration.js`)
- Removed `check_rack_state.js` from fix/orchestrator-fixes
- Removed `MR-connect-api/` backup folder
- Removed unit test files (moved to separate branch)

## üìö Essential Documentation

**READ THESE FIRST before making any code changes:**

1. `docs/reference/MERGE_ANALYSIS.md` - **CRITICAL**: Connect API MR scope creep and schema conflicts
2. `docs/reference/PROJECT-STATUS-22-09-2025.md` - Current implementation status and feature completion
3. `docs/reference/codebase-overview.md` - Complete architecture and technical decisions
4. `db/schema.sql` - Database schema with enhanced plate tracking
5. `docs/reference/OttoEngine-API-Documentation.md` - Complete API endpoint reference
6. `docs/reference/BACKEND-FILE-REFERENCE.md` - File structure and purpose guide
7. `docs/reference/rack-event-system.md` - Real-time event system specification
8. `docs/reference/rack-slot-bugfix-doc.md` - Recent critical fixes (Oct 2025)

## üéØ Current Development Focus

### Manual Orchestration System (Active)

**Current Mode:** Full manual control - users specify all resource allocations

**What's Required:**
- User selects printer, rack, store slot, and grab slot for each job
- System validates selections and prevents conflicts
- Sequential job processing with clear status visibility
- Smart console output (only shows updates when state changes)

**Key Systems to Understand:**
1. **OrchestratorService** (`src/services/orchestratorService.js`) - Job processing with manual assignments
2. **ManualSlotValidator** (`src/utils/ManualSlotValidator.js`) - Validates user selections
3. **RackEventEmitter** (`src/services/rackEventEmitter.js`) - Real-time state synchronization
4. **AdapterStateManager** (`src/services/adapterStateManager.js`) - Multi-brand printer control

**Deprecated (Preserved for Future):**
- **AdvancedSlotManager** (`src/utils/AdvancedSlotManager.js`) - Automatic slot optimization (Phase 2)
- **_findAvailablePrinter()** - Automatic printer selection (Phase 2)
- **assignSlotsForJob()** - Automatic slot assignment (Phase 2)

## üèóÔ∏è Project Architecture

```
Controllers ‚Üí Services ‚Üí Database
     ‚Üì
Routes + Middleware
     ‚Üì  
Device APIs (MQTT/HTTP)
     ‚Üì
Integration Adapters
```

### Key Directories

- `src/controllers/` - HTTP request handlers
- `src/services/` - Business logic (orchestration, job management, device control)
- `src/routes/` - API endpoint definitions
- `src/utils/` - AdvancedSlotManager, logger, helpers
- `src/bambulabs-api/` - Bambu Lab MQTT + FTP integration
- `packages/integration-adapter/` - Multi-brand printer adapter pattern
- `db/` - SQLite database and schema
- `_testing/postman/` - API test collection

## üíª Coding Guidelines

### Critical Rules

1. **NO assumptions** - Ask clarifying questions if unclear
2. **NO over-engineering** - Do exactly what's asked
3. **NO direct edits to `develop` branch** - Always create feature branches
4. **AVOID reading entire files** - Use targeted edits to prevent context limits

### Database Best Practices

**Three-State Rack Slot Model:**
```javascript
// no_plate (provides clearance)
{ has_plate: false, plate_state: null, occupied: false }

// empty_plate (ready for printing)
{ has_plate: true, plate_state: 'empty', occupied: false }

// plate_with_print (occupied)
{ has_plate: true, plate_state: 'with_print', occupied: true }
```

**Always update ALL fields when modifying rack slots:**
```javascript
await ottorackService.updateShelf(rackId, slotNumber, {
    has_plate: Boolean,
    plate_state: 'empty' | 'with_print' | null,
    occupied: Boolean,
    print_job_id: Number | null
});
```

### Service Layer Patterns

**Orchestrator Status Values:**
- `waiting` - Job queued, waiting for printer
- `printing` - Active print in progress
- `ejecting` - Removing from printer
- `storing` - Placing in storage rack
- `completed` - Workflow finished
- `paused` - Manual intervention required
- `failed` - Error occurred

**Printer Status Acceptance:**
Accept printers with status: `IDLE`, `FINISH`, or `FAILED` (FAILED printers can still receive commands)

### Event Emission Rules

**Always emit events when updating rack state manually:**
```javascript
const eventPayload = {
    eventType: 'shelfUpdated',
    rackId: parseInt(rackId),
    shelfId: parseInt(shelfId),
    previousState: previousState,
    newState: newState,
    printJobId: printJobId,
    timestamp: new Date().toISOString(),
    triggeredBy: 'manual_api'
};

rackEventEmitter.emit('rackStateChanged', eventPayload);
```

### Logging Standards

```javascript
const logger = require('../utils/logger');

// Use structured logging
logger.info(`[ServiceName] Action completed: ${details}`);
logger.warn(`[ServiceName] Warning condition: ${condition}`);
logger.error(`[ServiceName] Error occurred: ${error.message}`);
logger.debug(`[ServiceName] Debug info: ${debugData}`);
```

## üß™ Testing Workflows

### Automated Testing (Recommended)

**Use the automated setup script:**
```bash
node _testing/unit-test-1.js
```

**Before running, edit config (lines 48-70):**
- Printer IP, access code, serial number
- OttoEject IP address
- Print file paths (REQUIRED - must point to your .gcode.3mf files)

**See:** `_testing/UNIT_TEST_GUIDE.md` for complete instructions

### Manual Testing Sequence

1. **Create Rack with Empty Plates:**
```bash
POST /api/ottoracks
{
  "name": "A",
  "number_of_shelves": 6,
  "shelf_spacing_mm": 80,
  "bed_size": "256x256"
}

PUT /api/ottoracks/1/shelves/1
{
  "has_plate": true,
  "plate_state": "empty",
  "print_job_id": null
}
```

2. **Upload and Create Print Job (Manual Mode):**
```bash
POST /api/print-jobs/upload
# (multipart/form-data with .gcode.3mf file)

POST /api/print-jobs
{
  "print_item_id": 1,
  "printer_id": 1,
  "ottoeject_id": 1,
  "rack_id": 1,           // REQUIRED - Which rack to use
  "store_location": 4,    // REQUIRED - Slot to store completed print
  "grab_location": 3,     // REQUIRED - Slot to grab fresh plate from
  "auto_start": true,
  "priority": 1
}
```

3. **Monitor Orchestration:**
```bash
GET /api/orchestration/status
GET /api/orchestration/active-jobs
GET /api/print-jobs/{id}
```

### Diagnostic Tools

**Check Rack State:**
```bash
node src/check_rack_state.js
```

**Test Slot Algorithm:**
```bash
node test-slot-algorithm.js
```

**Postman Collection:**
Use `_testing/postman/OTTOMAT3D-API-Tests.postman_collection.json`

## üîç Common Debugging Patterns

### Slot Assignment Issues

**Check these in order:**
1. Verify rack slots have `has_plate=1` and `plate_state='empty'`
2. Confirm AdvancedSlotManager is receiving correct rack state
3. Check that `max_z_height_mm` is set on print_items
4. Verify clearance calculations in logs

**Expected Logs:**
```
[SlotManager] Finding storage for 2.16mm print (needs 12.16mm clearance)
[SlotManager] Selected slot 1 with score 0.620
```

### Orchestrator Not Starting Jobs

**Check these:**
1. Printer status is IDLE, FINISH, or FAILED
2. Job has `auto_start=true`
3. Orchestrator polling is active: `GET /api/orchestration/health`
4. Check for error logs in orchestrator service

### Event System Issues

**Verify:**
1. `rackEventEmitter` is imported correctly
2. Events are being emitted with all required fields
3. Orchestrator is listening: check `handleRackStateChange` logs
4. No circular event loops (check `triggeredBy` field)

## üö® Critical Bugs Fixed Recently

**Rack Slot Management (Oct 2025):**
- Fixed duplicate `updateShelf()` calls overwriting data
- Added `has_plate` and `plate_state` to SQL UPDATE statements
- Fixed route parameter names (`req.params.id` vs `req.params.ottorack_id`)
- Added FAILED printer status acceptance

**Reference:** `docs/reference/Rack Slot Management - Bug Fixes Oct 2025.md`

## üì¶ Dependencies

**Core:**
- `express` - Web framework
- `sqlite3` - Database
- `mqtt` - Bambu Labs communication
- `axios` - HTTP client for Moonraker/Klipper

**Development:**
- `nodemon` - Auto-reload server
- Postman - API testing

## üéØ Feature Branch Strategy

**Always create feature branches:**
```bash
git checkout develop
git pull origin develop
git checkout -b feat/descriptive-name
# ... make changes ...
git add .
git commit -m "feat: descriptive commit message"
git push origin feat/descriptive-name
```

**Branch Naming:**
- `feat/` - New features
- `fix/` - Bug fixes
- `test/` - Testing changes
- `docs/` - Documentation updates
- `refactor/` - Code improvements

## üîë Key Technical Decisions

### Why Adapter Pattern?
Multi-brand printer support without modifying core logic. Each printer vendor gets its own adapter implementing `IPrinterAdapter`.

### Why Height-Aware Slots?
30-40% better space utilization. Prevents blocking tall prints with inefficient placement.

### Why Event-Driven Architecture?
Sub-second detection of manual interventions with automatic conflict resolution (95%+ success rate).

### Why SQLite?
Embedded database simplifies deployment. Sufficient for single-instance operation. Can migrate to PostgreSQL if multi-instance needed.

## üéì Learning Resources

**Before modifying code, understand:**
1. Service layer separation (controllers call services, not database directly)
2. Adapter pattern for printer integration
3. Event emitter pattern for real-time updates
4. Three-state rack slot model
5. Height-aware slot scoring algorithm

## ‚úÖ Testing Checklist

When testing orchestration:
- [ ] Rack has empty plates in slots 1-2
- [ ] Print job has valid `max_z_height_mm`
- [ ] Printer is IDLE/FINISH/FAILED and reachable
- [ ] OttoEject device is online
- [ ] Orchestrator polling is active (check health endpoint)
- [ ] Database has no orphaned states
- [ ] Event system is emitting rack changes
- [ ] Logs show slot assignment reasoning

## üöÄ Current Sprint Goals

**Testing Phase 3 Features:**
1. End-to-end print workflow (upload ‚Üí print ‚Üí eject ‚Üí store)
2. Multi-job concurrent processing (2+ jobs simultaneously)
3. Height-aware slot assignment with various print sizes
4. Manual rack intervention during active automation
5. Conflict resolution and automatic reassignment
6. Error recovery and graceful degradation
7. 24-hour stability test

**Success Metrics:**
- Jobs complete without manual intervention
- Slot assignments are optimal (check scoring)
- Conflicts resolve automatically (95%+ rate)
- No memory leaks over 24-hour operation
- Real-time monitoring APIs responsive (<100ms)

## üìû Support

**Issues? Check:**
1. Merge conflicts and schema issues in `docs/reference/MERGE_ANALYSIS.md`
2. Recent bug fixes in `docs/reference/rack-slot-bugfix-doc.md`
3. API documentation in `docs/reference/OttoEngine-API-Documentation.md`
4. Architecture overview in `docs/reference/codebase-overview.md`
5. Database schema in `db/schema.sql`

---

**Project Status:** Production Ready - Phase 3 Complete
**Current Branch:** `feat/orchestration-nov2025`
**Last Updated:** October 30, 2025
**Development Phase:** Orchestration Enhancement Sprint
